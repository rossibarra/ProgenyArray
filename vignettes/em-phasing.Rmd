---
title: "EM Phasing"
output:
pdf_document:
  toc: false
  highlight: zenburn
---

```{r}
load_all("~/Projects/ProgenyArray")
library(rmarkdown)
library(Rcpp)
library(parallel)
library(caret)
library(reshape2)
options(mc.cores=4)
set.seed(42)
```

# Some Notes

Initialize based on k-means (k=2), and then shrink these probabilities.

(1) Remove all loci incomplete in all individuals early on.

(2) For E-step, we'll have to use all complete loci only. Note that for loci
that are homozygous in the other parent, we can trivially impute progeny
genotype to supply to this model -- this may be a valuable approach later on.

(3) $\pi_k$ for each of the $k \in \{1, 2\}$ haplotypes may be set to $1/2$ or
let vary as a free parameter. As a free parameter, this could be a useful
diagnostic, and potentially indicate when a region is homozygous in the shared
parent. Responsibilities are also a valuable diagnostic.

# EM

Prototype EM algorithm in R -- this won't be very idiomatic R since it's going
to be rewritten in C++.

```{r}

rowProds <- function(x, na.rm=FALSE) apply(x, 1, prod, na.rm=na.rm)

colProds <- function(x, na.rm=FALSE) apply(x, 2, prod, na.rm=na.rm)

logSumExpPosterior <- function(liks, pi) {
  # log sum exp trick for list of matrices of loci x individuals, each for a
  # particular haplotype
  bc <- t(mapply(function(x, p) colSums(log(x)) + log(p), liks, pi))

  # denominator (same for both haplotype probs), uses TLOP
  max_bc <- apply(bc, 2, max)
  scaled_bc  <- sweep(bc, 2, max_bc, FUN='-') # subtract B
  denom <- log(colSums(exp(scaled_bc))) + max_bc
  sweep(bc, 2, denom, FUN='-')
}

isConverged <- function(ll, ll_last, eps, debug=FALSE) {
  conv <- abs(ll_last - ll) < eps
  if (debug) message(sprintf("%d of %d individuals converged", sum(conv), length(conv)))
  if (all(conv)) return(TRUE)
  return(FALSE)
}

emHap <- function(x, parent, which_parent, partition, ehet, ehom, na_thresh=0.8, max_iter=60L, eps=1e-9) {
  nloci <- length(partition)
  nind <- ncol(progenyGenotypes(x))
  pi <- cbind(c(0.5, 0.5))
  resp <- matrix(0, nrow=nind, ncol=2)

  # get progeny for the supplied parent (according to which parent it is) --
  pars <- parents(x)
  d <- pars[pars[, as.character(which_parent)] == parent, ]
  other_parent <- setdiff(c("parent_1", "parent_2"), which_parent)

  # get this partition's genotypes
  pgeno <- progenyGenotypes(pa)[partition, ]
  fgeno <- parentGenotypes(pa)[partition, ]

  # prune some individuals with high missingness, so we can get an initial
  # estimate of cluster responsibility
  remove_inds <- pruneWhichIndividuals(pgeno, na_thresh)

  # initialize responsibilities
  a <- runif(nind)
  init_resp <- resp <- rbind(a, 1-a)

  # check that all other parents are within bounds parent genotype matrix
  stopifnot(d[, other_parent] %in% 1:ncol(fgeno))
  other_parents <- d[, other_parent] - 1L # since C++ is 0 indexed

  # calculate likelihoods for each shared parent allele being (0, 1) ONCE for
  # all individuals, progeny
  liks <- geno_ll(pgeno, fgeno, other_parents, freqs(x)[partition], ehet, ehom)

  thetas <- list()
  lls_inds <- list(list(), list())

  for (i in seq_len(max_iter)) {
    if (i > 1) {
      # get the total likehood given last MLE for all individuals' MLE alleles, for k in (1, 2)
      mlm1 <- max_ll_matrix(liks[[1]], liks[[2]], theta_mle[, 1])
      mlm2 <- max_ll_matrix(liks[[1]], liks[[2]], theta_mle[, 2])
      # individual log likelihoods
      ll1 <- colSums(log(mlm1))
      ll2 <- colSums(log(mlm2))
      # append these log likeloods to list
      lls_inds[[1]] <- c(lls_inds[[1]], list(ll1))
      lls_inds[[2]] <- c(lls_inds[[2]], list(ll2))

      # check for convergence, ll1(t), ll2(t), ll1(t-1), ll2(t-1)
      # use t - 2 here, since we just appened these LLs to list
      if (i > 2 && isConverged(ll1, lls_inds[[1]][[i-2]], eps) && isConverged(ll2, lls_inds[[2]][[i-2]], eps))
        break

     # E step
     ll_resp <- logSumExpPosterior(list(mlm1, mlm2), pi)
     resp <- exp(logSumExpPosterior(list(mlm1, mlm2), pi))
    }

    # M step
    # compute pi weights
    pi <- rowMeans(resp)

    # compute likelihoods for each (loci, individual). Returns a list of two matrices:
    # likelihood for 0 and 1 alleles of theta_k (k = haplotype)
    # TODO name, not log lik
    ll_weighted <- lapply(1L:2L, function(k) {
                          lapply(liks, function(lik) {
                                 # loops over likelihoods for an allele in (0, 1)
                                 sweep(log(lik), MARGIN=2, STATS=resp[k,], FUN=`*`)
                          })
    })
    # log likelihoods of each loci's allele, for both haplotypes k in (1, 2)
    lls <- lapply(ll_weighted, function(hap) do.call(cbind, lapply(hap, rowSums)))

    # MLE alleles for each haplotype k in (1, 2)
    theta_mle <- do.call(cbind, lapply(lls, function(x) apply(x, 1, which.max)-1L))
    thetas <- c(thetas, list(theta_mle))
  }
  ll <- do.call(rbind, mapply(function(x, hap) {
              d <- as.data.frame(do.call(rbind, x))
              colnames(d) <- paste('ind', seq_len(ncol(d)), sep="_")
              d$iter <- seq_len(nrow(d))
              d$hap <- hap
              d
  }, lls_inds, 1L:2L, SIMPLIFY=FALSE))
  ll <- setNames(melt(ll, id.vars=c('iter', 'hap')), c("iter", "hap", "ind", "ll"))
  return(list(haplos=theta_mle, cluster=resp, niter=i, ll=rbind(ll1, ll2), all_thetas=thetas, all_lls=ll))
}

```

```{r}

sf <- sibFamily(40, 1000, ehet=0.7, ehom=0.1)
pa <- ProgenyArray(sf$progeny, sf$genos, mothers=sf$metadata$mother)
pa <- calcFreqs(pa)
pa <- inferParents(pa, 0.8, 0.1)

res <- emHap(pa, 1L, "parent_1", 1:nrow(progenyGenotypes(pa)), 0.7, 0.1)


```

## Plots

```{r}

haps2dataframe <- function(x) {
  d <- data.frame(x=as.vector(row(x)), y=as.vector(col(x)), z=as.vector(x))
  d[order(d$x), ]
}

emPlot <- function(res, real_haps) {
  r1 <- confusionMatrix(res$haplos[, 1], real_haps[, 1])$overall['Accuracy']
  r2 <- confusionMatrix(res$haplos[, 1], real_haps[, 2])$overall['Accuracy']
  hap_order <- 1:2
  if (r2 > r1)
    hap_order <- 2:1
  ani.record(reset = TRUE)
  var_sites <- !apply(real_haps == 0, 1, all) # all zero sites
  #orig <- haps2dataframe(data.frame(rep(FALSE, nrow(real_haps)), rep(FALSE, nrow(real_haps))))
  #levelplot(z ~ x + y, orig, col.regions=c("red","white"))
  lapply(res$all_thetas, function(tt) {
       print(table(tt[var_sites, ] == real_haps[var_sites, hap_order[1]]))
       p <- levelplot(z ~ x + y, haps2dataframe((tt[var_sites, ] == real_haps[var_sites, hap_order])), col.regions=c("red","white"))
       #p <- ggplot(haps2dataframe(1L + (tt[var_sites, ] == real_haps[var_sites, hap_order]))) + geom_tile(aes(x=x,y=y, fill=z))
       print(p)
       browser()
       ani.record()
  })
  oopts = ani.options(interval = 0.5)
  browser()
}

```
